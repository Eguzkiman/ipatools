import type { NextPage } from "next";
import Head from "next/head";
import { useMemo, useState } from "react";
import { readCsvFile } from "./helpers/readCsvFile";
import { normalize } from "./helpers/normalize";
import { compareTwoStrings } from "string-similarity";

interface Item {
  [key: string]: string;
}

interface FieldsToInclude {
  [key: string]: boolean;
}
interface ResultType {
  fromListA: Item;
  fromListB: Item | null;
  matchQuality: number;
}

const Home: NextPage = () => {
  const [listA, setListA] = useState<Item[] | null>(null);
  const [listB, setListB] = useState<Item[] | null>(null);

  const [listAColumnName, setListAColumnName] = useState<string | null>(null);
  const [listBColumnName, setListBColumnName] = useState<string | null>(null);

  const [fieldsToIncludeFromA, setFieldsToIncludeFromA] =
    useState<FieldsToInclude | null>(null);
  const [fieldsToIncludeFromB, setFieldsToIncludeFromB] =
    useState<FieldsToInclude | null>(null);

  const [matchQualityThreshold, setMatchQualityThreshold] = useState("70");

  const [result, setResult] = useState<ResultType[] | null>(null);

  const listAColumnOptions = useMemo(() => {
    return Object.keys(listA?.[0] || {}).filter((key) => !!key.trim());
  }, [listA]);

  const listBColumnOptions = useMemo(() => {
    return Object.keys(listB?.[0] || {}).filter((key) => !!key.trim());
  }, [listB]);

  const filteredResult = useMemo(
    () =>
      result?.filter(
        ({ matchQuality }) => matchQuality >= Number(matchQualityThreshold)
      ),
    [result, matchQualityThreshold]
  );

  function findMatches() {
    if (!listA || !listB || !listAColumnName || !listBColumnName) return;

    const result: ResultType[] = [];

    for (let itemA of listA) {
      let bestMatchQuality = 0;
      let bestMatchItem: Item | null = null;

      for (let itemB of listB) {
        const strA = normalize(itemA[listAColumnName]);
        const strB = normalize(itemB[listBColumnName]);

        const matchQuality = compareTwoStrings(strA, strB) * 100;

        if (matchQuality > bestMatchQuality) {
          bestMatchItem = itemB;
          bestMatchQuality = matchQuality;
        }
      }

      if (!bestMatchItem?.[listBColumnName]) continue;

      result.push({
        fromListA: itemA,
        fromListB: bestMatchItem,
        matchQuality: bestMatchQuality,
      });
    }

    setResult(result);
  }

  return (
    <>
      <Head>
        <title>IPA Tools</title>
        <meta name="description" content="Generated by create next app" />
        <link rel="icon" href="/favicon.ico" />
      </Head>
      <h1>CSV Matcher</h1>
      <div style={{ display: "flex" }}>
        <div style={{ flex: 1 }}>
          <h2>Find items from this list...</h2>
          <input
            type="file"
            accept=".csv"
            onChange={async (e) => {
              const list = await readCsvFile(e.target.files?.[0]).catch((e) =>
                console.error({ e })
              );

              if (!list) return;

              const columns = Object.keys(list[0]);
              setListAColumnName(columns[0]);
              setListA(list);

              const fieldsToInclude: FieldsToInclude = {};
              for (let column of columns) {
                fieldsToInclude[column] = true;
              }

              setFieldsToIncludeFromA(fieldsToInclude);
              setResult(null);
            }}
          />
          <br />
          <br />
          <label htmlFor="listAColumnName">Column name:</label>{" "}
          <select
            name="listAColumnName"
            id="listAColumnName"
            onChange={(e) => {
              setListAColumnName(e.target.value);
              setResult(null);
            }}
            value={listAColumnName || undefined} // yikes
          >
            {listAColumnOptions.map((columnOption) => (
              <option key={columnOption} value={columnOption}>
                {columnOption}
              </option>
            ))}
          </select>
        </div>
        <div style={{ flex: 1 }}>
          <h2>On this list...</h2>
          <input
            type="file"
            accept=".csv"
            onChange={async (e) => {
              const list = await readCsvFile(e.target.files?.[0]).catch((e) =>
                console.error({ e })
              );
              if (!list) return;

              const columns = Object.keys(list[0]);
              setListBColumnName(columns[0]);
              setListB(list);

              const fieldsToInclude: FieldsToInclude = {};
              for (let column of columns) {
                fieldsToInclude[column] = true;
              }

              setFieldsToIncludeFromB(fieldsToInclude);
              setResult(null);
            }}
          />
          <br />
          <br />
          <label htmlFor="listBColumnName">Column name:</label>{" "}
          <select
            name="listBColumnName"
            id="listBColumnName"
            onChange={(e) => {
              setListBColumnName(e.target.value);
              setResult(null);
            }}
          >
            {listBColumnOptions.map((columnOption) => (
              <option key={columnOption} value={columnOption}>
                {columnOption}
              </option>
            ))}
          </select>
        </div>
      </div>
      <br />
      <br />
      <label htmlFor="sourceColumnName">Match quality threshold %</label>{" "}
      <input
        id="sourceColumnName"
        type="number"
        value={matchQualityThreshold}
        min={0}
        max={100}
        onChange={(e) => setMatchQualityThreshold(e.target.value)}
      />
      <br />
      <br />
      <button onClick={findMatches}>Find Matches</button>
      {result && fieldsToIncludeFromA && fieldsToIncludeFromB && (
        <>
          <h3>
            {filteredResult?.length} / {result?.length} matches found
          </h3>
          <div
            style={{
              border: "1px solid #ccc",
              maxHeight: "250px",
              overflow: "auto",
            }}
          >
            <pre>
              <ul>
                {filteredResult?.map(
                  ({ fromListA, fromListB, matchQuality }, index) => {
                    if (!listAColumnName || !listBColumnName) {
                      return "Missing column names";
                    }

                    const strA = fromListA[listAColumnName];
                    const strB = fromListB?.[listBColumnName];

                    return (
                      <li key={fromListA[listAColumnName] + index}>
                        [{matchQuality < 100 ? " " : ""}
                        {matchQuality < 10 ? " " : ""}
                        {matchQuality.toFixed(0)}% match] <b>{strA}</b> -{" "}
                        <b>{strB || "no match"}</b>
                      </li>
                    );
                  }
                )}
              </ul>
            </pre>
          </div>
          <br />
          <br />
          <div style={{ display: "flex" }}>
            <div style={{ flex: 1 }}>
              <h3>Include from this list</h3>

              {listAColumnOptions.map((columnOption) => (
                <>
                  <input
                    type="checkbox"
                    checked={fieldsToIncludeFromA[columnOption]}
                    onChange={(e) => {
                      setFieldsToIncludeFromA({
                        ...fieldsToIncludeFromA,
                        [columnOption]: e.target.checked,
                      });
                    }}
                  />
                  <label htmlFor="">{columnOption}</label>
                  <br />
                </>
              ))}
            </div>
            <div style={{ flex: 1 }}>
              <h3>Include from this list</h3>
              {listBColumnOptions.map((columnOption) => (
                <>
                  <input
                    type="checkbox"
                    checked={fieldsToIncludeFromB[columnOption]}
                    onChange={(e) => {
                      setFieldsToIncludeFromB({
                        ...fieldsToIncludeFromB,
                        [columnOption]: e.target.checked,
                      });
                    }}
                  />
                  <label htmlFor="">{columnOption}</label>
                  <br />
                </>
              ))}
            </div>
          </div>
          <br />
          <input type="checkbox" />
          <label htmlFor="">Include match quality in result</label>
          <br />
          <br />
          <br />
          <button>Download Result</button>
        </>
      )}
    </>
  );
};

export default Home;
